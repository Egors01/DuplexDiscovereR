---
title: "DuplexDiscovereR tutorial"
author:
  - name: "Egor Semenchenko"
    affiliation: Max Delbrück Center for molecular medicine; Berlin Institute for Medical Systems Biology; Freie Universität Berlin  
    email: egorsbs01@gmail.com
package: DuplexDiscovereR
abstract: |
    DuplexDiscovereR implements methods for analysing data from RNA cross-linking 
    and proximity ligation protocols such as SPLASH, PARIS, LIGR-seq 
    and other methods, ehich yeild information on RNA-RNA interactions as 
    chimeric read fragments after high-throughput sequencing. 
bibliography: '`r system.file("references.bib", package = "DuplexDiscovereR")`'
output:
  BiocStyle::html_document:
    toc: true
    toc_depth: 2
vignette: |
  %\VignetteIndexEntry{DuplexDiscovereR tutorial}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8} 
--- 

```{r style, echo = FALSE, results = 'asis'}
BiocStyle::markdown(css.files = c("custom.css"))
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "##",
    crop = FALSE
)
```
# Installation

`DuplexDiscovereR` can be installed from Bioconductor: 

```{r install_chunk, eval=FALSE}
if (!require("BiocManager", quietly = TRUE)) install.packages("BiocManager")

BiocManager::install("DuplexDiscovereR")

library(DuplexDiscovereR)
?DuplexDiscovereR
```
or github page 

```{r install_chunk2, eval=FALSE}
if (!require("BiocManager", quietly = TRUE)) install.packages("BiocManager")

library(devtools)
devtools::install_github("Egors01/DuplexDiscovereR")
```

## Installing RNAduplex 

For calculating hybridization energies `DuplexDiscovereR` uses [RNAduplex](https://www.tbi.univie.ac.at/RNA/RNAduplex.1.html) program from the
[ViennaRNA](https://www.tbi.univie.ac.at/RNA/) software suite. 


Although this step is optional and is not required for using most of the package methods, 
we strongly recommend installing ViennaRNA from its [web-page](https://www.tbi.univie.ac.at/RNA/), 
as predicting RNA hybrids is one of the central aims of the analysis of RNA-RNA interaction data. 
Please note that ViennaRNA is distributed under its own licence.

# Introduction 

RNA cross-linking and proximity ligation methods as SPLASH, PARIS, LIGR-seq, 
RIC-seq and others provide infromation on the RNA-RNA 
interactions on a transcriptome-wide scale. These experiments generate
high-throughput sequencing data containing a fraction of chimeric reads, where 
each chimeric part corresponds to the base-paired stretches of RNA (RNA duplexes)

`DuplexDiscovereR` is designed for bioinformatic analysis of 
RNA data. It employs a workflow, which allow users to identify RNA duplexes
and provides multiple options to filter and rank results.

Starting from the set of aligned chimeric reads, it implements 
classification and filtering of non-RNA duplex  alignments and their
clustering into duplex groups (DGs). Identified DGs are then annotated with  
transcripts or other genomic features. P-values are calculated to test the
hypothesis that DGs are generated by random ligation. Finally, RNA duplex 
base-pairing and hybridization energies are predicted.

The optimal procedures for identifying RNA duplexes may vary between methods, 
as RNA-RNA interaction probing protocols are known to have biases for certain 
types of RNA and differ in experimental steps. `DuplexDiscovereR` allows user 
to build customized analysis by utilizing it methods for efficient chimeric read
clustering and classification and convenience functions for flexible data
filtering, annotation and visualization. 

RNA duplex data is known to be sparse and there is often little overlap between 
the results of different probing protocols. To facilitate comparisons between
different experiments and to allow straightforward cross-checking between
replicates, `DuplexDiscovereR` includes functionality to intersect multiple RNA
interaction datasets.  

`DuplexDiscovereR` relies on the `GInteractions` container from
`r Biocpkg("InteractionSet")` package for the storage of 
the RNA-RNA interaction data and uses tidyverse `tibble` and `dplyr` for 
internal data transformations. For visualization,
`DuplexDiscovereR` comes with the `r Biocpkg("Gviz")` - based `DuplexTrack` track and 
supports export of the results to the .sam file.

# Quick start

##  Key analysis steps 

Key steps of RNA duplex data analysis with DuplexDiscovereR can be run through the single function call.
It is expected that user already aligned the raw sequencing reads, wihch produced
some chimeric or split-read alignments. The input can be provided in several formats:

- Table-like data with the split-read alignments
  - From Chimeric.out.junction file generated by STAR 
  - In .bedpe forant (defined in [bedtools](https://bedtools.readthedocs.io/en/latest/content/general-usage.html#bedpe-format) 
  - `GInteractions` object.
  chimeric alignments. 
In case of .bedpe or `GInteractions`, all entries are already represented as 
reads with two different aligned parts (2-arm)

Full `DuplexDiscovereR` workflow consists of the following steps: 
- Pre-processing of the input. For the chimeric alignment generated by STAR, this step calls the classification based in the CIGAR strings 
  - 2arm reads (only one chimeric junction per aligned read)
  - multi-split (two or more one chimeric junctions per aligned read)
  - multi-mapped reads 
- Comparing the 2arm chimericly mapped reads against the splice junctions. Alignments across the exon-exon junctions typically contaminate the 'true' chimeric alignments originated from the RNA duplexes 
- Deduplication of the identical read alignments
- Clustering into DGs

*Optionally*,  

- Annotation of the DGs with transcript or other features
- Prediction of the base-pairing hybridization energies
- Computing p-values from testing the probability of random ligation 

## Key input arguments

- Required inputs for minimal workflow run are
  - `data` Chimeric read alignments or coordinates. Object of any table type, convertible to `tibble` or `GInteractions`
  - `junctions_gr` `GRanges` object with splice junction coordinates.  
  - Library type and type of the read table, if input is not `GInteractions`.
- Optional inputs for executing the full workflow
  - `anno_gr` a `GRanges` object with genes or transcripts annotation object
  - `df_counts` a 2-column table with the `id` in the 1st column  and raw read count in the 2nd. `id` should correspond to the entries in `anno_gr`.
      Providing this argument  triggers p-value calculation. 
  - `fafile` a path to .fasta file with the genome. Providing this argument triggers prediction of RNA hybrids.

## Loading example data

Once installed, we can load the example data. Example dataset is based on the 
RNA duplex probing of SPLASH ES-cells [Aw. et.al 2016](https://pubmed.ncbi.nlm.nih.gov/27184079/), which was aligned with STAR [Dobin et.al, 2013](https://academic.oup.com/bioinformatics/article-abstract/29/1/15/272537) and subset to
the chromosome 22.



```{r dataload,echo=T,eval=T,message=FALSE}
library(DuplexDiscovereR)
data(RNADuplexesSampleData)
```
Details on alignment of the reads of example dataset and fetching of the annotation data are
described in the file, which could be found at 
```{r dataload2 }
system.file("extdata", "scripts", "DD_data_generation.R", package = "DuplexDiscovereR")
```

## Calling analysis
```{r run_workflow, echo=T,eval=T,message=FALSE}
# library(DuplexDiscovereR)
# data(RNADuplexesSampleData)
genome_fasta <- NULL
result <- DuplexDiscovereR::runDuplexDiscoverer(
    data = RNADuplexesRawChimSTAR,
    junctions_gr = SampleSpliceJncGR,
    anno_gr = SampleGeneAnnoGR,
    df_counts = RNADuplexesGeneCounts,
    sample_name = "example_run",
    lib_type = "SE",
    table_type = "STAR",
    fafile = genome_fasta,
)
```

The `result` is a list object containing several outputs with different dimensions. 
```{r observe_results1,eval=TRUE}
names(result)
```
`gi_clusters` is a `GInteractions` with the collapsed duplex groups
```{r observe_results2,eval=TRUE}
head(result$gi_clusters, 2)
```
`gi_reads` is a `r Biocpkg("GInteractions")` where each entry is an individual read.

```{r observe_results3,eval=TRUE}
head(result$gi_reads, 2)
```
Dimensions of the `gi_reads` does not have 1:1 correspondence to the size of the input, 
as usually not every element in the input data can be represented as the 2-arm split alignment.
To track the fate of each input alignment, one can use `df_reads` - an output dataframe, which preseves
the same length as input. It has added fields as DG `dg_id` or `read_type`, showing the outcome of 
chimeric read classification and filtering.

```{r observe_results4,eval=TRUE}
table(result$df_reads$read_type)
```
Among the 2-arm alignments from `gi_reads`, only un-ambigously aligned reads without 
self-ovelaps which pass splice-jucntions and minimum junction lenghtfilters are 
subjected to clustering into DGs. To see the determined types of 2-arm 
alignments, we can check 'junction_type' metadata field
```{r observe_results5,eval=TRUE}
table(result$gi_reads$junction_type)
```

## Writing output 
The resulting `GInteractions` with duplex groups are ready for integration 
into transcriptomic analysis using other Bioconductor packages.

There are several options available for outputting the results for other uses.

### Output to table 
One can convert object with duplex groups to dataframe -like object and write to file
```{r write_table, eval=TRUE}
clusters_dt <- makeDfFromGi(result$gi_clusters)
write.table(clusters_dt, file = tempfile(pattern = "dgs_out", fileext = ".tab"))
```
### Output to .sam file 
Saving results to .sam file can be useful tool for downstream 
visualization with interactive viewers as IGV
```{r write_sam, eval=TRUE, message = FALSE}
writeGiToSAMfile(result$gi_clusters, file_out = tempfile(pattern = "dgs_out", fileext = ".sam"), genome = "hg38")
```

## Visualization 

Collapsed duplex groups could be visualized with Gviz -based DuplexTrack , 
allowing overlays of RNA duplexes with the genes of other features 

```{r, vis_1, eval=TRUE,message=FALSE}
library(Gviz)
# define plotting region
plotrange <- GRanges(
    seqnames = "chr22",
    ranges = IRanges(
        start = c(37877619),
        end = c(37878053)
    ),
    strand = "+"
)
# make genes track
anno_track <- Gviz::GeneRegionTrack(SampleGeneAnnoGR,
    name = "chr22 Genes",
    range = plotrange
)
# construct DuplexTrack
duplex_track <- DuplexTrack(
    gi = result$gi_clusters,
    gr_region = plotrange,
    labels.fontsize = 12,
    arcConstrain = 4,
    annotation.column1 = "gene_name.A",
    annotation.column2 = "gene_name.B"
)
plotTracks(list(anno_track, duplex_track),
    sizes = c(1, 3),
    from = start(plotrange) - 100,
    to = end(plotrange) + 100
)
```      

## Calcualting hybridization energies 
In the example above, we omitted prediction of the base-pairing and calculation
of the hybridization energies by not providing the
path to the genome through `fafile` argument. 
However, predicting RNA hybrids is central to the RNA-RNA interaction data analysis. 

To compute the structure formed by two stretches of RNA `DuplexDiscoverer` uses 
**RNAduplex** algorithm from **ViennaRNA**. Note that **ViennaRNA** is distributed 
under its own licence. Please refer 
to the https://www.tbi.univie.ac.at/RNA/ViennaRNA/doc/html/license.html for details

If the **RNAduplex** is installed, one can re-run all steps
of the analysis with `runDuplexDiscoverer` specifying the genome by
setting option `fafile = <path to genome>`
Alternatively, one can predict RNA hybrids by calling separate function on
`GInteractions` object: 

```
sequence <- paste0(
"AGCUAGCGAUAGCUAGCAUCGUAGCAUCGAUCGUAAGCUAGCUAGCUAGCAUCGAUCGUAGCUAGCAUCGAU",
"CGUAGCAUCGUAGCUAGCUAGCUAUGCGAUU")

# Save the sequence to a temp fasta file
fasta_file = tempfile(fileext = '.fa')
chrom <- "test_chrA"
writeLines(c(">test_chrA", sequence), con = fasta_file)

# Create the GInteraction object
# Define start and end positions for the base-pairing regions
regions <- data.frame(
  start1 = c(1, 11, 21, 31, 41),
  end1 = c(10, 20, 30, 40, 50),
  start2 = c(91, 81, 71, 61, 51),
  end2 = c(100, 90, 80, 70, 60)
)
# GRanges objects for the anchors
anchor1 <- GRanges(seqnames = chrom, ranges = IRanges(start = regions$start1, end = regions$end1))
anchor2 <- GRanges(seqnames = chrom, ranges = IRanges(start = regions$start2, end = regions$end2))
interaction <- GInteractions(anchor1, anchor2)
# predict hybrids
getRNAHybrids(interaction,fasta_file)

```
## Comparing multiple samples or replicates
Due to the sparce nature of RNA duplex data, it is desirable to be able to 
compare replicates of the single experiment or compare different datasets.

`DuplexDiscovereR` provides a method for finding intersections between multiple 
samples. Comparisons between ranges can result in one-to-many 
relations, i.e if one range (or pair of ranges) of one sample contains multiple 
ranges from other samples. `DuplexDiscovereR` addresses this problem by using 
following procedure: first it computes a non-redundant set of interactions, which 
stacks and collapses interactions from all input samples. This resulting 
super-set is then compared in a pairwise manner with every entry from each individual sample. 

To demonstrate how multiple samples can be compared, we will generate three pseudo-replicates
from the example data which we clustered above. 


We will firt select clustered reads and split them into three groups
```{r comp1, eval=TRUE}
clust_reads <- result$gi_reads
clust_reads <- clust_reads[!is.na(clust_reads$dg_id)]

# Create separate pseudo-sample objects for each group
set.seed(123)
group_indices <- sample(rep(1:3, length.out = length(clust_reads)))

group1 <- clust_reads[group_indices == 1]
group2 <- clust_reads[group_indices == 2]
group3 <- clust_reads[group_indices == 3]
```

Because individual reads were already assigned to duplex groups, 
we can collapse them, which will ensure we will have some overlaps between the 
reads belonging to the same'true' DGs, but distributed 
into three artificial sets.
```{r comp2, eval=TRUE}
group1 <- collapse_duplex_groups(group1)
group2 <- collapse_duplex_groups(group2)
group3 <- collapse_duplex_groups(group3)
```

```{r comp3, eval=TRUE, message=FALSE}
a <- list("sample1" = group1, "sample2" = group2, "sample3" = group3)
res_comp <- compareMultipleInteractions(a)
names(res_comp)
```
Result contains slot for the interaction superset and the overlap information
We can visualize sample intersections via upset plot 
```{r comp4, eval=TRUE}
# first, check if UpSetR is installed
if (!requireNamespace("UpSetR", quietly = TRUE)) {
    stop("Install 'UpSetR' to use this function.")
}
library(UpSetR)
upset(res_comp$dt_upset, text.scale = 1.5)
```



# Building customized duplex data analysis with DuplexDiscovereR 
One can customize analysis by running classification, clustering and subsequent
annotation procedures step-by-step, adjusting procedures to fit the RNA-RNA 
interaction probing protocol or upstream/downstream analysis

In this section we show, how user can use core package methods
## Preprocecing
Most of the core methods in `DuplexDiscovereR` work with the RNA-RNA inteaction data 
stored in `GInteraction` - object. 
There are several metadata fields which are not strictly required by the package,
but utilized in procedures run classification: `map_type` or clustering 
`n_reads`,`score`, `read_id` 

The easiest way to use `DuplexDiscovereR` methods is to start with a preprocessing 
routine. It is very flexible in input type: can be either 
`GInteractions` or Chimeric.out Junction file from STAR 

```{r,  preproc ex1, message=FALSE}
data("RNADuplexesSampleData")

new_star <- runDuplexDiscoPreproc(
    data = RNADuplexesRawChimSTAR,
    table_type = "STAR",
    library_type = "SE",
)
```
bedpe - formatted dataframe. 
```{r,  preproc ex2, message=FALSE}
new_bedpe <- runDuplexDiscoPreproc(
    data = RNADuplexesRawBed,
    table_type = "bedpe",
    library_type = "SE", return_gi = TRUE
)
```

By default, to make downstream read filtering slightly more convenient,
`tibble` is returned after the preprocessing. 
In case of the `GInteractions` input, input reads already are 2-arm split 
by design, so we can return `GInteractions` . 
```{r,  preproc ex3, message=FALSE}
# keep only readname in metadata
mcols(RNADuplexSampleGI) <- mcols(RNADuplexSampleGI)["readname"]
new_gi <- runDuplexDiscoPreproc(data = RNADuplexSampleGI, return_gi = TRUE)
head(new_gi, 1)
```

## Classification and filtering 
The basic clasisfication routines implemented in the backage are
comparisons of the chimeric junctions to the known splice junctions and 
determining the types of the overlaps. 
Both can be called by separate method, which adds corresponding metadata field
to the input
```{r ex_classif1}
gi <- getChimericJunctionTypes(new_gi)
gi <- getSpliceJunctionChimeras(gi, sj_gr = SampleSpliceJncGR)
```
 One can inspect detected jucntoin types
```{r ex_classif2}
table(gi$junction_type)
```
and amount of reads, which are not liikely to come from true RNA duplexes, bacause
their chimeric junctions are too similar to normal exon-exon junction
```{r ex_cassif3}
table(gi$splicejnc)
```
For determining the duplex groups, we will leave only chiemric junctions in a 
read which do not self-overlap
```{r }
keep <- which((gi$junction_type == "2arm") & (gi$splicejnc == 0))
gi <- gi[keep]
```
## Clustering reads into duplex groups 

The most basic way to find the duplex groups is to simply call 
```{r clust1, message=FALSE}
gi <- clusterDuplexGroups(gi)
```
This procedure will:

1. Find overlaps between all chimeric read pairs.
2. Represent reads as a directed graph, where edges are weighted with the amount of overlap between the reads.
3. Call a community search algorithm on the graph, which finds the read clusters.
4. Add the read cluster IDs as the `dg_id` field to the input object.
`NA` values used for reads which are not a part of any read duplex group (DG)
```{r ex_clust2}
table(is.na(gi$dg_id))
```
to collapse reads to the DGs with the re-defined boundaries, containing every 
memeber of DG, one can call 
```{r ex_clist3}
gi_dgs <- collapse_duplex_groups(gi)
head(gi_dgs, 1)
# number of DGs
length(gi_dgs)
```
The advantage of this procedure is that it can be applied on any subset of data 
with varying parameters. This allows users, who are willing to focus interesting
RNA structure at particular region to select all reads overlapping with this 
region and re-run clustering multiple times, with adjusted the parameters 
(minimum overlap , maximum allowed gap between alignment arms coordinates)
to obtain more duplex groups with more refined boundaries for subsequent 
prediction of the RNA secondary structure.

## Customization of the read clustering

### Collapsing identical reads
For large datasets, it is possible to identify and collapse identical reads -
those that map to the same coordinates with the same score. 
In overlap-based clustering, these reads would belong to the same duplex groups.
Collapsing them into a single entry reduces the number of nodes and vertices
in the clustering graph, resulting in better time and memory performance.
```{r , dupl1 }
res_collapse <- collapseIdenticalReads(gi)
# returns new object
gi_unique <- res_collapse$gi_collapsed
```
This procedure adds `duplex_id` column as new id and removes `read_id`, 
because single entry in a new object can correspond to multiple reads.
`n_reads` records the number of reads in this temporary duplex group.

```{r dupl2 }
head(res_collapse$stats_df, 1)
```
Note that `collapse_duplex_groups()` method has options to handle
temporary duplex groups, so mergind identical reads before clustering would not lost 
information on the read support for duplex group. 

```{r dupl3, message=FALSE}
# cluster  gi_unqiue
gi_unique_dg <- collapse_duplex_groups(clusterDuplexGroups(gi_unique))
# check if the get the same amount of reads as in basic clustering
sum(gi_unique_dg$n_reads) == sum(gi_dgs$n_reads)
```
### Custom weights for clustering

There is a possibility for a user to re-define the rules by which overlaps 
between reads are weighted before community search. 

This might be a customization related to protocols or the size of the dataset. 
Possible scenarios are weighting the clustering graph vertices with hybridization energies
calculated directly on the reads instead of duplex groups, or to use some other
heuristic assumptions on how RNA duplexes are translated into chimeric read fragments
i.e in RIL-seq, the second chimeric arm is more likely to be a target RNA rather than 
sRNA.

To modify the graph weights, one can use following procedure
Call the finding of the pair overlaps in the input `GInteractions` object 
```{r cl1}
graph_df <- computeGISelfOverlaps(gi_unique)
head(graph_df)
```
This data frame size is determined by the presence of pairwise overlap between
both arms of read alignments. 
The first two columns represent the element index or `duplex_id` of 
the corresponding reads. It can be filtered or supplemented with other 
relevant metrics of the pairwise relationship between the reads.

In this example, we will manually restrict the span-to-overlap ratio per pair 
or overlapping alignment arms, taking their sum as the new weight after
re-scaling the values to {0,1}.

```{r cl2}
graph_df <- graph_df[graph_df$ratio.A > 0.5 & graph_df$ratio.B > 0.5, ]
rescale_vec <- function(x) {
    return((x - min(x)) / (max(x) - min(x)))
}

graph_df$weight_new <- graph_df$ratio.A + graph_df$ratio.B
graph_df$weight_new <- rescale_vec(graph_df$weight_new)
head(graph_df, 2)
```

This dataframe can then be passed as an argument to the clustering function

```{r cl3, message=FALSE}
gi_clust_adj <- clusterDuplexGroups(gi_unique, graphdf = graph_df, weight_column = "weight_new")
gi_clust_adj_dgs <- collapse_duplex_groups(gi_clust_adj)
```
We will get smaller number of the duplex groups, as some of them will be 
lost after restricting the minimum required overlap
```{r cl4}
length(gi_clust_adj)
```


# Session information 
```{r session-info,cache = F,echo=T,message=T,warning=FALSE}
sessionInfo()
```

