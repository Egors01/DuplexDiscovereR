---
title: "DuplexDiscoverer tutorial"
author:
  - name: "Egor Semenchenko"
    affiliation: Max Delbrück Center for molecular medicine; Berlin Institute for Medical Systems Biology; Freie Universität Berlin  
    email: egorsbs01@gmail.com
package: DuplexDiscoverer
abstract: |
  DuplexDiscoverer implements methods for analysing data from RNA cross-linking and proximity ligation protocols such as SPLASH, PARIS, LIGR-seq and other methods recording information on RNA-RNA interactions as chimeric fragments after high-throughput sequencing. 
bibliography: '`r system.file("references.bib", package = "DuplexDiscoverer")`'
output:
  BiocStyle::html_document:
    toc: true
    toc_depth: 2
vignette: |
  %\VignetteIndexEntry{DuplexDiscoverer tutorial}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8} 
--- 

```{r style, echo = FALSE, results = 'asis'}
BiocStyle::markdown(css.files = c("custom.css"))
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "##",
    crop = FALSE
)
```
# Installation

`DuplexDiscoverer` can be installed from Bioconductor: 

```{r install_chunk, eval=FALSE}
if (!require("BiocManager", quietly = TRUE)) install.packages("BiocManager")

BiocManager::install("DuplexDiscoverer")

library(DuplexDiscoverer)
?DuplexDiscoverer
```

## Installing RNAduplex 

For calculating hybridization energies `DuplexDiscoverer` uses [RNAduplex](https://www.tbi.univie.ac.at/RNA/RNAduplex.1.html) program from the
[ViennaRNA](https://www.tbi.univie.ac.at/RNA/) software suite. 


Although this step is optional and is not required for using most of the package methods, 
we strongly recommend installing ViennaRNA from its [web-page](https://www.tbi.univie.ac.at/RNA/), 
as predicting RNA hybrids is one of the central aims of the analysis of RNA-RNA interaction data. 
Please note that ViennaRNA is distributed under its own licence.

# Introduction 

RNA cross-linking and proximity ligation methods as SPLASH, PARIS, LIGR-seq, 
RIC-seq and others provide infromation on the RNA-RNA 
interactions on a transcriptome-wide scale. These experiments generate
high-throughput sequencing data containing a fraction of chimeric reads, where 
each chimeric part corresponds to the base-paired stretches of RNA (RNA duplexes)

`DuplexDiscoverer` is designed for bioinformatic analysis of 
RNA data. It employs a workflow, which allow users to identify RNA duplexes
and provides multiple options to filter and rank results.

Starting with the set of aligned chimeric reads, it implements their 
and clustering into duplex groups (DGs), Identified DGs are then annotated with 
transcript or other genomic features. P-values are calculated to test the
hypothesis that DGs are generated by random ligation.
Finally, RNA duplex base pairing steps and hybridisation energies are predicted.

The optimal procedures for identifying RNA duplexes may vary between methods, as 
RNA-RNA interaction probing protocols. `DuplexDiscoverer` enables user to build 
customized analysis by utilizing it methods for efficient
chimeric read clustering and classification and convenience functions for 
flexible data filtering, annotation and visualization. 

RNA duplex data is known to be sparse and there is often little overlap 
between the results of different probing protocols. To facilitate comparisons 
between different experiments and allow straightforward cross-checking between 
replicates, `DuplexDiscoverer` includes functionality to intersect the multiple
RNA interaction datasets.  

`DuplexDiscoverer` relies on the `GInteractions` container from
`r Biocpkg("InteractionSet")` package for storing 
the RNA-RNA interaction data and uses tidyverse tools for internal data 
transformations. For visualization, `DuplexDiscoverer` is supplied with the `Gviz` - based 
`RNAduplexTrack` track and supports export of the results to the .sam file.

# Quick start

##  Key analysis steps 

Key steps of RNA duplex data analysis with DuplexDiscoverer can be run through the single function call.
It is expected that user already aligned the raw sequencing reads, wich produced
some chimeric or split alignments. The input can be provided in different formats. 
- Table-like data with the split-read alignments
  - From Chimeric.out.junction file generated by STAR 
  - In .bedpe formant (defined in [bedtools](https://bedtools.readthedocs.io/en/latest/content/general-usage.html#bedpe-format) 
  - `GInteractions` object. In this case, all entries will be already represented as 2-arm
  chimeric alignments. 

Full workflow consists of the following steps: 

- Pre-processing of the input. For the chimeric alignment generated by STAR, this step calls the classification based in the CIGAR strings 
  - 2arm reads (only one chimeric junction per aligned read)
  - multi-split (two or more one chimeric junctions per aligned read)
  - multi-mapped reads 
- Comparing the 2arm chimericly mapped reads against the splice junctions. Alignments across the exon-exon junctions typically contaminate the 'true' chimeric alignments  originated from the RNA duplexes 
- Deduplication of the reads
- Clustering into DGs

*Optionally*,  

- Annotation of the DGs with transcript or other features
- Prediction of the base-pairing hybridization energies
- Computing p-values from testing the probability of random ligation 

## Key input arguments

- Required inputs for minimal workflow run are
  - `data` Chimeric read alignments or coordinates. Object of any table type, convertible to `tibble` or `GInteractions`
  - `junctions_gr` `GRanges` object with splice junction coordinates.  
  - Library type and type of the read table, if input is not `GInteractions`.
- Optional inputs for executing the full workflow
  - `anno_gr` a `GRanges` object with genes or transcripts annotation object
  - `df_counts` a 2-column table with the `id` in the 1st column  and raw read count in the 2nd. `id` should correspond to the entries in `anno_gr`.
      Providing this argument  triggers p-value calculation. 
  - `fafile` a path to .fasta file with the genome. Providing this argument triggers prediction of RNA hybrids.

## Loading example data

Once installed, we can load the example data. Example dataset is based on the 
RNA duplex probing of SPLASH ES-cells [Aw. et.al 2016](https://pubmed.ncbi.nlm.nih.gov/27184079/), which was aligned with STAR [Dobin et.al, 2013](https://academic.oup.com/bioinformatics/article-abstract/29/1/15/272537) and subset to
the chromosome 22.

Analysis will start 

```{r dataload,echo=T,eval=T,message=FALSE}
library(DuplexDiscoverer)
data(RNADuplexesSampleData)
```
## Calling analysis
```{r run_workflow, echo=T,eval=T,message=FALSE}
# library(DuplexDiscoverer)
# data(RNADuplexesSampleData)
genome_fasta <- NULL
result <- DuplexDiscoverer::runDuplexDiscoverer(
    data = RNADuplexesRawChimSTAR,
    junctions_gr = SampleSpliceJncGR,
    anno_gr = SampleGeneAnnoGR,
    df_counts = RNADuplexesGeneCounts,
    sample_name = "example_run",
    lib_type = "SE",
    table_type = "STAR",
    fafile = genome_fasta,
)
```

The `result` is a list object containing several outputs with different dimensions. 
```{r observe_results1,eval=TRUE}
names(result)
```
`gi_clusters` is a `GInteractions` with the collapsed duplex groups
```{r observe_results2,eval=TRUE}
head(result$gi_clusters, 2)
```
`gi_reads` is a `r Biocpkg("GInteractions")` where each entry is an individual read.

```{r observe_results3,eval=TRUE}
head(result$gi_reads, 2)
```
Dimensions of the `gi_reads` does not have 1:1 correspondence to the size of the input, 
as not every element in the input data can be represented as the 2-arm split alignment.
To track the fate of each input read, one can use `df_reads` - an output dataframe, which preseves
the same length as input. It has added fields as DG `dg_id` or `read_type`, showing the outcome of 
chimeric read classification and filtering.

```{r observe_results4,eval=TRUE}
table(result$df_reads$read_type)
```
Among the 2-arm alignments from `gi_reads`, only un-ambigously aligned reads without 
self-ovelaps which pass splice-jucntiona and minimum junction lenghtfilters are 
subjected to clustering into DGs. To see the determined types of 2-arm 
alignments, we can check 'junction_type' metadata field
```{r observe_results5,eval=TRUE}
table(result$gi_reads$junction_type)
```

## Writing output 

### Output to table 
To save, one can convert object with duplex groups to dataframe -like object and write to file
```{r write_table, eval=TRUE}
clusters_dt <- DuplexDiscoverer::makeDfFromGi(result$gi_clusters)
write.table(clusters_dt, file = tempfile(pattern = "dgs_out", fileext = ".tab"))
```
### Output to .sam file 
```{r write_sam, eval=TRUE, message = FALSE}
writeGiToSAMfile(result$gi_clusters, file_out = tempfile(pattern = "dgs_out", fileext = ".sam"), genome = "hg38")
```
To save to .sam file

## Visualization 

Collapsed duplex groups could be visualized with Gviz -based DuplexTrack , 
allowing overlays of RNA duplexes with the genes of other features 

```{r, vis_1, eval=TRUE,message=FALSE}
library(Gviz)
# define plotting region
plotrange <- GRanges(
    seqnames = "chr22",
    ranges = IRanges(
        start = c(37877619),
        end = c(37878053)
    ),
    strand = "+"
)
# make genes track
anno_track <- Gviz::GeneRegionTrack(SampleGeneAnnoGR,
    name = "chr22 Genes",
    range = plotrange
)
# construct DuplexTrack
duplex_track <- DuplexTrack(
    gi = result$gi_clusters,
    gr_region = plotrange,
    labels.fontsize = 12,
    arcConstrain = 4,
    annotation.column1 = "gene_name.A",
    annotation.column2 = "gene_name.B"
)
plotTracks(list(anno_track, duplex_track),
    sizes = c(1, 3),
    from = start(plotrange) - 100,
    to = end(plotrange) + 100
)
```      

## Calcualting hybridization energies 
In the example above, we omitted prediction of the base-pairing and calculation
of the hybridization energies by not providing the
path to the genome through `fafile` argument. 
However, predicting RNA hybrids is central to the RNA-RNA interaction data analysis. 

If the **ViennaRNA** external dependency is installed, one can re-run all steps
of the analysis with `runDuplexDiscoverer` with option `fafile = <path to genome>`
Alternatively, one can predict RNA hybrids by calling separate function on
`GInteractions` object: 

```
sequence <- paste0(
"AGCUAGCGAUAGCUAGCAUCGUAGCAUCGAUCGUAAGCUAGCUAGCUAGCAUCGAUCGUAGCUAGCAUCGAU",
"CGUAGCAUCGUAGCUAGCUAGCUAUGCGAUU")

# Save the sequence to a temp fasta file
fasta_file = tempfile(fileext = '.fa')
chrom <- "test_chrA"
writeLines(c(">test_chrA", sequence), con = fasta_file)

# Create the GInteraction object
# Define start and end positions for the base-pairing regions
regions <- data.frame(
  start1 = c(1, 11, 21, 31, 41),
  end1 = c(10, 20, 30, 40, 50),
  start2 = c(91, 81, 71, 61, 51),
  end2 = c(100, 90, 80, 70, 60)
)
# GRanges objects for the anchors
anchor1 <- GRanges(seqnames = chrom, ranges = IRanges(start = regions$start1, end = regions$end1))
anchor2 <- GRanges(seqnames = chrom, ranges = IRanges(start = regions$start2, end = regions$end2))
interaction <- GInteractions(anchor1, anchor2)
# predict hybrids
getRNAHybrids(interaction,fasta_file)

```
## Comparing multiple samples or replicates
Due to the sparce nature of RNA duplex data, it is desirable to be able to 
compare replicates of the single experiment or compare different datasets.

`DuplexDiscoverer` provides a method for finding intersections between multiple 
samples. Comparisons between ranges can result in one-to-many 
relations, i.e if one range (or pair of ranges) of one sample contains multiple 
ranges from other samples. `DuplexDiscoverer` addresses this problem by using 
following procedure: first it computes a non-redundant set of interactions, which 
stacks and collapses interactions from all input samples. This resulting 
super-set is then compared in a pairwise manner with every entry from each individual sample. 

To demonstrate how multiple samples can be compared, we will generate three pseudo-replicates
from the example data which we clustered above. 


We will firt select clustered reads and split them into three groups
```{r comp1, eval=TRUE}
clust_reads <- result$gi_reads
clust_reads <- clust_reads[!is.na(clust_reads$dg_id)]

# Create separate pseudo-sample objects for each group
set.seed(123)
group_indices <- sample(rep(1:3, length.out = length(clust_reads)))

group1 <- clust_reads[group_indices == 1]
group2 <- clust_reads[group_indices == 2]
group3 <- clust_reads[group_indices == 3]
```

Because individual reads were already assigned to duplex groups, 
we can collapse them, which will ensure we will have some overlaps between the 
reads belonging to the same'true' DGs, but distributed 
into three artificial sets.
```{r comp2, eval=TRUE}
group1 <- collapse_duplex_groups(group1)
group2 <- collapse_duplex_groups(group2)
group3 <- collapse_duplex_groups(group3)
```

```{r comp3, eval=TRUE, message=FALSE}
a <- list("sample1" = group1, "sample2" = group2, "sample3" = group3)
res_comp <- compareMultipleInteractions(a)
names(res_comp)
```
Result contains slot for the interaction superset and the overlap information
We can visualize sample intersections via upset plot 
```{r comp4, eval=TRUE}
# first, check if UpSetR is installed
if (!requireNamespace('UpSetR', quietly = TRUE))
    stop("Install 'UpSetR' to use this function.")
library(UpSetR)
upset(res_comp$dt_upset, text.scale = 1.5)
```

# Building customized duplex data analysis with DuplexDiscoverer 
One can customize analysis by running classification, clustering and subsequent
annotation procedures step-by-step, adjusting procedures to fit the RNA-RNA 
interaction probing protocol or upstream/downstream analysis

In this section we show, how user can use core package methods
## Preprocecing
Most of the core methods in `DuplexDiscoverer` work with the RNA-RNA inteaction data 
stored in `GInteraction` - object. 
There are several metadata fields which are not strictly required by the package,
but utilized in procedures run classification: `map_type` or clustering 
`n_reads`,`score`, `read_id` 

The easiest way to use `DuplexDiscoverer` methods is to start with a preprocessing 
routine. It is very flexible in input type: can be either 
`GInteractions` or Chimeric.out Junction file from STAR 

```{r,  preproc ex1, message=FALSE}
data("RNADuplexesSampleData")

new_star <- runDuplexDiscoPreproc(
    data = RNADuplexesRawChimSTAR,
    table_type = "STAR",
    library_type = "SE",
)
```
bedpe - formatted dataframe. 
```{r,  preproc ex2, message=FALSE}
new_bedpe <- runDuplexDiscoPreproc(
    data = RNADuplexesRawBed,
    table_type = "bedpe",
    library_type = "SE", return_gi = TRUE
)
```

By default, to make downstream read filtering slightly more convenient,
`tibble` is returned after the preprocessing. 
In case of the `GInteractions` input, input reads already are 2-arm split 
by design, so we can return `GInteractions` . 
```{r,  preproc ex3, message=FALSE}
# keep only readname in metadata
mcols(RNADuplexSampleGI) <- mcols(RNADuplexSampleGI)["readname"]
new_gi <- runDuplexDiscoPreproc(data = RNADuplexSampleGI, return_gi = TRUE)
head(new_gi, 1)
```

# Classification and filtering 
The basic clasisfication routines implemented in the backage are
comparisons of the chimeric junctions to the known splice junctions and 
determining the types of the overlaps. 
Both can be called by separate method, which adds corresponding metadata field
to the input
```{r ex_classif1}
gi <- get_chimeric_junction_types(new_gi)
gi <- get_splice_junction_chimeras(gi, sj_gr = SampleSpliceJncGR)
```
 One can inspect detected jucntoin types
```{r ex_classif2}
table(gi$junction_type)
```
and amount of reads, which are not liikely to come from true RNA duplexes, bacause
their chimeric junctions are too similar to normal exon-exon junction
```{r ex_cassif3}
table(gi$splicejnc)
```
For determining the duplex groups, we will leave only chiemric junctions in a 
read which do not self-overlap
```{r }
keep <- which((gi$junction_type == "2arm") & (gi$splicejnc == 0))
gi <- gi[keep]
```
## Clustering reads into duplex groups 

The most basic way to find the duplex groups is to simply call 
```{r clust1, message=FALSE}
gi <- clusterDuplexGroups(gi)
```
This will run an procedure, which 
- 1. finds overlaps between all chimeric read pairs 
- 2. represents reads as the directed graph, where edges are weighted with the 
amount of overlap between the reads. 
- 3. Calls community search algorithm is then called on the graph, which finds the read clusters. 
- 4. The read cluster ids are added as `dg_id` field to the input object

`NA` values used for reads which are not a part of any read duplex group (DG)
```{r ex_clust2}
table(is.na(gi$dg_id))
```
to collapse reads to the DGs with the re-defined boundaries, containing every 
memeber of DG, one can call 
```{r ex_clist3}
gi_dgs <- collapse_duplex_groups(gi)
head(gi_dgs, 1)
# number of DGs
length(gi_dgs)
```
The advantage of this procedure is that it can be called on any subset of data with 
changed parameters. This allows users, willing to focus interesting RNA structure at particular region to 
select all reads overlapping with this region and re-run clustering multiple times, 
adjusting the parameters (minimum overlap , maximum allowed gap between alignment arms coordinates)
to get more refined duplex groups for subsequent prediction of the RNA secondary structure

## Customization of the read clustering

### Collapsing identical reads
For a datasets of a big size, it is possible to identify and collapse identical
reads - these which map to the same coordinates with the same score. 
In the overlap-based clustering, these reads would belong to the same duplex groups. 
Collapsing them into single entry reduces the number of nodes and vertices in
the clustering graph, resulting in better time and memory performance.  
```{r , dupl1 }
res_collapse <- collapse_identical_reads(gi)
# returns new object
gi_unique <- res_collapse$gi_collapsed
```
This procedure adds `duplex_id` column as new id and removes `read_id`, 
because single entry in a new object can correspond to multiple reads.
`n_reads` records the number of reads in this temporary duplex group.

```{r dupl2 }
head(res_collapse$stats_df, 1)
```
Note that `collapse_duplex_groups()` method has options to handle
temporary duplex groups, so mergind identical reads before clustering would not lost 
information on the read support for duplex group. 

```{r dupl3, message=FALSE}
# cluster  gi_unqiue
gi_unique_dg <- collapse_duplex_groups(clusterDuplexGroups(gi_unique))
# check if the get the same amount of reads as in basic clustering
sum(gi_unique_dg$n_reads) == sum(gi_dgs$n_reads)
```
### Custom weights for clustering

There is a possibility for a user to re-define the rules by which overlaps 
between reads are weighted before community search. 

This might be a customization related to protocols or the size of the dataset. 
Possible scenarios are weighting the clustering graph vertices with hybridization energies
calculated directly on the reads instead of duplex groups, or to use some other
heuristic assumptions on how RNA duplexes are translated into chimeric read fragments
i.e in RIL-seq, the second chimeric arm is more likely to be a target RNA rather than 
sRNA.

To modify the graph weights, one can use following 
Call the finding of the pair overlaps in the input gi 
```{r cl1}
graph_df <- compute_gi_self_overlaps(gi_unique)
head(graph_df)
```
This dataframe size is detemined by the existence of the pairwise overlap between
both read arms. First two columns stand for the element index or `duplex_id` of 
the corresponding reads.
It can be filtered or supplemented with other relevant metrics for pairwise 
relation between reads.

In this example, we will manually restrict the span-to-overlap ratio, use 
their sum as the new weight after re-scaling the values to {0,1}

```{r cl2}
graph_df <- graph_df[graph_df$ratio.A > 0.5 & graph_df$ratio.B > 0.5, ]
rescale_vec <- function(x) {
    return((x - min(x)) / (max(x) - min(x)))
}

graph_df$weight_new <- graph_df$ratio.A + graph_df$ratio.B
graph_df$weight_new <- rescale_vec(graph_df$weight_new)
head(graph_df, 2)
```

This dataframe can then be passed as an arguemnt to the clustering function

```{r cl3, message=FALSE}
gi_clust_adj <- clusterDuplexGroups(gi_unique, graphdf = graph_df, weight_column = "weight_new")
gi_clust_adj_dgs <- collapse_duplex_groups(gi_clust_adj)
```
We will get smaller number of the duplex groups, as some of them will be 
lost after restricting the minimum required overlap
```{r cl4}
length(gi_clust_adj)
```



# Session information 
```{r session-info,cache = F,echo=T,message=T,warning=FALSE}
sessionInfo()
```

